{"version":3,"sources":["webpack:///./node_modules/codemirror/addon/dialog/dialog.js","webpack:///./node_modules/codemirror/keymap/emacs.js","webpack:///./node_modules/codemirror/addon/fold/foldcode.js","webpack:///./node_modules/codemirror/lib/codemirror.js","webpack:///./node_modules/codemirror/keymap/vim.js","webpack:///./node_modules/codemirror/addon/hint/anyword-hint.js","webpack:///./node_modules/codemirror/addon/lint/lint.js","webpack:///./node_modules/codemirror/addon/edit/matchbrackets.js","webpack:///./node_modules/vue-codemirror/dist/vue-codemirror.js","webpack:///./node_modules/codemirror/keymap/sublime.js","webpack:///./node_modules/codemirror/addon/hint/show-hint.js","webpack:///./node_modules/codemirror/addon/lint/yaml-lint.js","webpack:///./node_modules/codemirror/addon/search/searchcursor.js","webpack:///./node_modules/codemirror/addon/fold/foldgutter.js","webpack:///./node_modules/codemirror/mode/yaml/yaml.js","webpack:///./shell/plugins/codemirror.js","webpack:///./node_modules/codemirror/mode/javascript/javascript.js"],"names":["mod","CodeMirror","dialogDiv","cm","template","bottom","dialog","wrap","getWrapperElement","appendChild","document","createElement","className","innerHTML","addClass","closeNotification","newVal","state","currentNotificationClose","defineExtension","callback","options","this","closed","me","close","inp","value","rmClass","parentNode","removeChild","focus","onClose","button","getElementsByTagName","selectValueOnOpen","select","onInput","on","e","onKeyUp","onKeyDown","keyCode","closeOnEnter","blur","e_stop","closeOnBlur","evt","relatedTarget","callbacks","buttons","blurring","i","length","b","e_preventDefault","setTimeout","doneTimer","duration","clearTimeout","cmds","commands","Pos","posEq","a","line","ch","killRing","addToRing","str","push","shift","growRingTop","getFromRing","n","Math","min","popFromRing","pop","lastKill","_kill","from","to","ring","text","getRange","pos","isClean","gen","replaceRange","changeGeneration","byChar","dir","findPosH","byWord","byLine","findPosV","doc","sel","goalColumn","byPage","byParagraph","no","getLine","sawText","test","slice","fst","firstLine","lst","lastLine","clipPos","hasText","bySentence","sawWord","next","charAt","byExpr","findMatchingBracket","strict","match","forward","first","token","getTokenAt","after","start","end","string","newPos","getPrefix","precise","digits","emacsPrefix","clearPrefix","Number","repeated","cmd","f","execCommand","prefix","findEnd","by","move","extendSelection","getCursor","motion","killTo","cursor","selections","listSelections","head","_killRegion","somethingSelected","selection","anchor","addPrefix","digit","maybeClearPrefix","maybeDuplicateInput","prefixPreservingKeys","arg","emacsPrefixMap","hasOwnProperty","off","event","dup","origin","one","join","txt","replaceSelection","maybeRemovePrefixMap","removeKeyMap","prefixMap","clearMark","setExtending","setCursor","makePrompt","msg","fragment","createDocumentFragment","input","setAttribute","style","width","createTextNode","getInput","openDialog","prompt","operateOnWord","op","toEnclosingExpr","stack","setMark","getExtending","killRegion","killLineEmacs","killRingSave","getSelection","yank","setSelection","yankPop","forwardChar","backwardChar","deleteChar","deleteForwardChar","deleteBackwardChar","forwardWord","backwardWord","killWord","backwardKillWord","nextLine","previousLine","scrollDownCommand","scrollUpCommand","backwardParagraph","forwardParagraph","backwardSentence","forwardSentence","killSentence","backwardKillSentence","killSexp","backwardKillSexp","forwardSexp","backwardSexp","markSexp","transposeSexps","leftStart","leftEnd","rightEnd","rightStart","backwardUpList","justOneSpace","openLine","transposeCharsRepeatable","capitalizeWord","w","letter","search","toUpperCase","toLowerCase","upcaseWord","downcaseWord","undoRepeatable","keyboardQuit","newline","gotoLine","num","isNaN","indentRigidly","indentSelection","getOption","exchangePointAndMark","quotedInsertTab","universalArgument","addKeyMap","emacs","kill","keyMap","normalizeKeyMap","regPrefix","d","String","doFold","force","call","finder","minSize","allowFolded","range","marks","findMarksAt","__isFold","cleared","clear","myWidget","makeWidget","myRange","markText","replacedWith","clearOnEnter","signal","widget","cloneNode","newFoldFunction","rangeFinder","toggleFold","foldCode","fold","unfold","scanUp","foldAll","operation","unfoldAll","registerHelper","funcs","Array","prototype","arguments","found","helpers","getHelpers","cur","defaultOptions","auto","minFoldSize","name","undefined","editorOptions","foldOptions","defineOption","global","factory","module","exports","userAgent","navigator","platform","gecko","ie_upto10","ie_11up","exec","edge","ie","ie_version","documentMode","webkit","qtwebkit","chrome","chrome_version","presto","safari","vendor","mac_geMountainLion","phantom","ios","maxTouchPoints","android","mobile","mac","chromeOS","windows","presto_version","flipCtrlCmd","captureRightClick","classTest","cls","RegExp","node","current","index","removeChildren","count","childNodes","firstChild","removeChildrenAndAdd","parent","elt","tag","content","cssText","eltP","contains","child","nodeType","host","activeElt","activeElement","body","shadowRoot","joinClasses","as","split","createRange","endNode","r","setEnd","setStart","createTextRange","moveToElementText","collapse","moveEnd","moveStart","selectInput","display","wrapper","ownerDocument","win","defaultView","bind","args","apply","copyObj","obj","target","overwrite","prop","countColumn","tabSize","startIndex","startValue","nextTab","indexOf","selectionStart","selectionEnd","_e","Delayed","id","time","handler","onTimeout","array","self","Date","set","ms","scrollerGap","Pass","toString","sel_dontScroll","scroll","sel_mouse","sel_move","findColumn","goal","col","skipped","spaceStrs","spaceStr","arr","map","out","insertSorted","score","priority","splice","nothing","createObj","base","props","inst","Object","create","nonASCIISingleCaseWordChar","isWordCharBasic","isWordChar","helper","source","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","findFirst","pred","midF","mid","ceil","floor","iterateBidiSections","order","part","max","level","bidiOther","getBidiPartAt","sticky","bidiOrdering","lowTypes","arabicTypes","charType","code","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","direction","outerType","len","types","i$1","prev","type","i$2","type$1","i$3","prev$1","type$2","i$4","type$3","replace","j","i$5","cur$1","type$4","i$6","end$1","before","replace$1","j$1","m","i$7","at","isRTL","j$2","nstart","unshift","reverse","getOrder","noHandlers","emitter","addEventListener","attachEvent","_handlers","concat","getHandlers","removeEventListener","detachEvent","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_target","srcElement","e_button","which","ctrlKey","zwspSupported","badBidiRects","dragAndDrop","div","zeroWidthElement","measure","offsetHeight","offsetWidth","hasBadBidiRects","r0","getBoundingClientRect","r1","left","right","splitLinesAuto","result","l","nl","rt","hasSelection","window","te","parentElement","compareEndPoints","hasCopyEvent","oncopy","badZoomedRects","hasBadZoomedRects","normal","fromRange","abs","modes","mimeModes","defineMode","mode","dependencies","defineMIME","mime","spec","resolveMode","getMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","properties","copyState","nstate","val","innerMode","info","startState","a1","a2","StringStream","lineOracle","lastColumnPos","lastColumnValue","lineStart","size","Error","chunk","lines","children","sz","chunkSize","getBetween","iter","getLines","updateLineHeight","height","diff","lineNo","lineAtHeight","h","outer","lh","isLine","lineNumberFor","lineNumberFormatter","firstLineNumber","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","last","clipToLen","linelen","clipPosArray","eol","sol","peek","eat","ok","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","indentation","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","inner","lookAhead","oracle","baseToken","SavedContext","Context","maxLookAhead","baseTokens","baseTokenPos","highlightLine","context","forceToEnd","st","modeGen","lineClasses","runMode","loop","o","overlay","overlays","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","findStartLine","saved","fromSaved","processLine","viewFrom","viewTo","startAt","stream","callBlankLine","readToken","blankLine","copy","Token","takeToken","asArray","tokens","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","indented","retreatFrontier","sawReadOnlySpans","sawCollapsedSpans","seeReadOnlySpans","seeCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","addMarkedSpan","inThisOp","WeakSet","markedSpans","has","add","attachLine","markedSpansBefore","old","startCh","isInsert","nw","startsBefore","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","offset","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","clearWhenEmpty","removeReadOnlyRanges","markers","mark","readOnly","parts","mk","find","p","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","collapsedSpanAround","conflictingCollapsedRange","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","findMaxLine","maxLine","maxLineLength","maxLineChanged","Line","estimateHeight","updateLine","estHeight","cleanUpLine","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","cache","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","rest","addToken","buildToken","buildTokenBadBidi","allowFrontierUpdate","externalMeasured","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","startStyle","endStyle","css","attributes","displayText","special","specialChars","mustWrap","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","attr","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","upto","tokenText","LineView","hidden","buildViewArray","nextPos","view","operationGroup","pushOperation","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","cursorActivityCalled","finishOperation","endCb","orphanDelayedCallbacks","signalLater","list","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","zIndex","updateLineBackground","background","insertBefore","getLineContent","ext","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","k","gutterSpecs","gutterWidth","alignable","isWidget","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","gutters","clientWidth","eventInWidget","getAttribute","sizer","mover","paddingTop","lineSpace","offsetTop","paddingVert","paddingH","cachedPaddingH","getComputedStyle","currentStyle","data","parseInt","paddingRight","scrollGap","nativeBarWidth","displayWidth","scroller","barWidth","displayHeight","clientHeight","barHeight","ensureLineHeights","rect","wrapping","lineWrapping","curWidth","heights","rects","getClientRects","top","mapFromLineView","updateExternalMeasurement","lineMeasure","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","key","measureCharInner","bogus","rtop","rbottom","measureText","nullRect","nodeAndOffsetInLineMap","mStart","mEnd","coverStart","coverEnd","getUsefulRect","place","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","cachedCharWidth","cachedTextHeight","lineNumChars","pageScrollX","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","ref","intoCoordSystem","includeWidgets","yOff","viewOffset","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","get","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","rangeEnd","wrappedLineExtent","begin","wrappedLineExtentChar","targetTop","boxIsAfter","box","ltr","coordsBidiPartWrapped","coordsBidiPart","baseX","chAround","boxAround","atLeft","atStart","_lineNo","closestDist","endX","dist","textHeight","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","posFromMouse","liberal","forRect","space","clientX","clientY","e$1","colDiff","round","regChange","lendiff","updateLineNumbers","viewChanged","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","customCursor","$customCursor","ranges","primIndex","empty","drawSelectionCursor","showCursorWhenSelecting","drawSelectionRange","cursorHeight","charPos","defaultCharWidth","otherCursor","cmpCoords","padding","leftSide","rightSide","sizerWidth","docLTR","drawForLine","fromArg","toArg","lineLen","wrapX","side","extent","fromPos","toPos","openStart","openEnd","openLeft","openRight","topLeft","topRight","botLeft","botRight","sFrom","sTo","fromLine","toLine","singleVLine","restartBlink","focused","clearInterval","blinker","cursorDiv","visibility","cursorBlinkRate","setInterval","hasFocus","onBlur","ensureFocus","onFocus","delayBlurEvent","delayingBlurEvent","draggingText","selForContextMenu","reset","receivedFocus","updateHeightsInViewport","prevBottom","lineDiv","viewTop","oldHeight","mustScroll","updateWidgetHeight","chWidth","visibleLines","viewport","ensure","ensureFrom","ensureTo","maybeScrollWindow","doScroll","innerHeight","scrollNode","scrollIntoView","scrollPosIntoView","margin","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","gutterSpace","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","isScroller","scrollWidth","alignHorizontally","measureForScrollbars","gutterW","docH","viewHeight","viewWidth","barLeft","docHeight","NativeScrollbars","vert","horiz","tabIndex","checkedZeroWidth","minHeight","minWidth","update","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","bar","delay","maybeDisable","elementFromPoint","NullScrollbars","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","heightForcer","borderBottom","scrollbarFiller","coverGutterNextToScrollbar","gutterFiller","scrollbarModel","initScrollbars","scrollbarStyle","axis","nextOpId","startOperation","updateInput","typing","changeObjs","selectionChanged","updateMaxLine","markArrays","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","setDocumentHeight","postUpdateDisplay","wheelStartX","wheelStartY","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","methodOp","docMethodOp","highlight","highlightWorker","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","visible","editorIsHidden","wrapperHeight","oldDisplayWidth","events","scrollbarsClipped","marginBottom","borderRightWidth","selectionSnapshot","active","anchorNode","extend","anchorOffset","focusNode","focusOffset","restoreSelection","snapshot","nodeName","removeAllRanges","addRange","renderedView","maybeUpdateLineNumberWidth","viewportMargin","different","lastWrapHeight","lastWrapWidth","toUpdate","selSnapshot","patchDisplay","selectionDiv","reportedViewFrom","reportedViewTo","updateNumbersFrom","container","rm","currentWheelTarget","updateNumber","updateGutterSpace","alignWidgets","comp","align","innerW","lineGutter","lineNumInnerWidth","lineNumWidth","getGutters","sawLineNumbers","renderGutters","specs","gElt","updateGutters","Display","clipPath","draggable","wheelDX","wheelDY","activeTouch","init","wheelSamples","wheelPixelsPerUnit","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","onScrollWheel","chromeScrollHack","pointerEvents","pixelsPerUnit","deltaMode","deltaX","deltaY","canScrollX","canScrollY","pixels","movedX","movedY","sample","Selection","equals","here","there","deepCopy","Range","normalizeSelection","mayTouch","selectionsMayTouch","prim","sort","inv","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","hint","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","spansFor","linesFor","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","directionChanged","History","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","history","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","addSelectionToHistory","clearRedo","dest","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","newChanges","extendRange","posBefore","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","setSelectionNoUndo","NaN","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","preventCursorLeft","selectLeft","preventCursorRight","selectRight","atomic","near","movePos","far","cantEdit","selectAll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","suppress","antiChanges","filter","returned","v","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","assign","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","removeInner","insertInner","iterN","remaining","leaf","maybeSpill","spilled","sibling","myIndex","used","LineWidget","opt","adjustScrollWhenAboveVisible","addLineWidget","insertAt","aboveVisible","this$1","oldH","nextMarkerId","TextMarker","markTextShared","addToHistory","curLine","clearHistory","withOp","visual","dHeight","SharedTextMarker","isParent","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","nextDocId","Doc","lineSep","cleanGeneration","constructor","getValue","lineSeparator","setValue","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","extendSelectionsBy","setSelections","addSelection","getSelections","replaceSelections","undo","redo","undoSelection","redoSelection","historySize","markClean","forceSplit","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","lastDrop","onDrop","clearDragCursor","files","dataTransfer","isReadOnly","FileReader","File","read","markAsReadAndPasteIfAllFilesAreRead","t","readTextFromFile","file","allowDropFileTypes","reader","onerror","onload","readAsText","text$1","getData","selected","onDragStart","setData","effectAllowed","setDragImage","img","src","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","editors","globalsRegistered","ensureGlobalHandlers","registerGlobalHandlers","resizeTimer","onResize","setSize","keyNames","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","145","173","186","187","188","189","190","191","192","219","220","221","222","224","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","fromCharCode","normalizeKeyName","alt","ctrl","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","addModifierNames","noShift","altKey","metaKey","shiftKey","keyName","altGraphKey","deleteNearSelection","compute","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","moveVisually","bidi","mv","getWrappedLineExtent","searchInVisualLine","getRes","res","nextCh","basic","pcDefault","emacsy","macDefault","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","leftPos","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","lineStartSmart","goLineEnd","lineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","transposeChars","newlineAndIndent","sels","indentLine","toggleOverwrite","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","lookupKeyForEditor","keyMaps","extraKeys","stopSeq","dispatchKey","seq","keySeq","dispatchKeyInner","handleKeyBinding","handleCharBinding","lastStoppedKey","getField","handled","showCrossHair","up","onKeyPress","charCode","lastClick","lastDoubleClick","DOUBLECLICK_DELAY","PastClick","clickRepeat","now","compare","onMouseDown","supportsTouch","clickInGutter","repeat","selectingText","handleMappedButton","leftButtonDown","onContextMenu","configureMouse","option","unit","addNew","moveOnDrag","contained","behavior","dragDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","preventScroll","e2","rangeForUnit","findWordAt","doc$1","ourRange","ourIndex","startSel","lastPos","extendTo","startCol","posCol","oldRange","ranges$1","bidiSimplify","editorSize","counter","curCount","anchorLine","boundary","headIndex","usePart","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","theme","Init","defaults","optionHandlers","defineOptions","deflt","notOnInit","newBreaks","refresh","getInputField","spellcheck","autocorrect","autocapitalize","detach","attach","wrappingChanged","integer","readOnlyChanged","screenReaderLabelChanged","dragDropChanged","resetPosition","wasOn","dragFunctions","toggle","enter","over","leave","drop","inputStyles","inputStyle","pasteIncoming","cutIncoming","autofocus","registerEventHandlers","finishInit","initHooks","textRendering","word","touchFinished","prevTouch","finishTouch","isMouseLikeTouchEvent","touch","radiusX","radiusY","farAway","pageX","pageY","how","aggressive","indent","curSpace","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","defineInitHook","lastCopied","setLastCopied","newLastCopied","applyTextInput","inserted","deleted","recent","paste","textLines","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","disableBrowserMagic","field","hiddenTextarea","border","addEditorMethods","setOption","getDoc","addOverlay","modeSpec","removeOverlay","newRanges","getLineTokens","getTokenTypeAt","getHelper","help","_global","getStateAfter","defaultTextHeight","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","hitSide","rtlMoveVisually","goals","headPos","startChar","check","scrollTo","getScrollInfo","interpret","swapDoc","phrase","phraseText","phrases","getScrollerElement","getGutterElement","registerGlobalHelper","predicate","origDir","lineDir","findNextLine","moveOnce","boundToLine","astral","sawType","pageSize","moveAmount","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","posToDOM","isInGutter","scan","badPos","bad","domTextBetween","closing","extraLinebreak","recognizeMarker","addText","walk","cmText","markerID","isBlock","textContent","nodeValue","domToPos","lineNode","locateNodeInLineView","textNode","topNode","curNode","previousSibling","dist$1","belongsToInput","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","contentEditable","updateFromDOM","readFromDOMSoon","forceCompositionEnd","label","removeAttribute","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","poll","pollSelection","pollInterval","pollContent","fromIndex","fromNode","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","TextareaInput","prevInput","pollingFast","resetting","fromTextArea","textarea","tabindex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","addLegacyProps","cmpPos","createField","prepareCopyCut","fastPoll","dispatchEvent","Event","_display","moveInputWithCursor","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","resetSelectionOnContextMenu","oldScrollY","oldCSS","oldWrapperCSS","wrapperBox","offsetParent","scrollY","rehide","detectingSelectAll","prepareSelectAllHack","mouseup","extval","disabled","dontDelegate","method","func","defineDocExtension","version","initVim$1","transformCursor","vim","insertMode","visualBlock","defaultKeymap","toKeys","action","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","shouldMoveCursor","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","onCursorActivity","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","attachVimMap","cmKey","vimKey","cmKeyToVimKey","vimApi","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Enter","Backspace","Delete","Insert","pieces","lastPiece","hasCharacter","piece","isUpperCase","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","upperCaseChars","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","validRegisters","_","isLowerCase","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","defaultValue","aliases","cfg","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","tail","buffer","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","inc","oldPointer","cachedCursor","createInsertModeChanges","c","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","dom","class","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","el","mapclear","userKeymap","contexts","defineEx","exCommands","commandMap_","handleKey","command","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","console","handleEx","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","getRepeat","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","isValidRegister","append","shiftNumericRegisters_","nextMatch","element","pushInput","bestMatch","matches","commandMatches","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","showPrompt","onPromptClose","desc","onPromptKeyUp","onPromptKeyDown","expandWordUnderCursor","isKeyword","escapeRegex","ignoreCase","smartCase","updateSearchQuery","showConfirm","logSearchQuery","parsedQuery","findNext","clearSearchHighlight","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","updateMark","cursorIsBefore","lastSel","lineOffset","chOffset","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","tmp","expandSelectionToLine","clipToLine","exclusive","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","posV","hasMarkedText","moveToStartOfLine","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","orig","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","re","matched","bracketRegex","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","textObjectManipulation","mirroredPairs","selfPaired","'","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","fn","fillArray","times","finalHead","MAX_VALUE","replacement","lastState","prevLineEnd","wasLastLine","startLine","endLine","_args","changeCase","swapped","toSwap","endPos","jumpListWalk","lineHeight","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","getLastEditPos","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","whitespaceLength","tabs","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","lastCh","extendLineToColumn","repeatFn","setRegister","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","cur3","cur1before2","cur2before3","trim","s","isClipped","curHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","fromCh","toCh","getHead","moveHead","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","bracket","isComplete","symb","depth","reverseSymb","section","curMoveThrough","comment","preprocess","curCh","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isBoundary","any","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","scanForBracket","chars","firstIndex","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","escapeNextChar","translateRegex","specials","unescape","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","$color","$whiteSpace","openNotification","alert","innerText","$fontFamily","shortText","regexEqual","r2","rawQuery","matchSol","searchState","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","colorscheme","mapArgs","imap","nmap","vmap","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","unique","parseArgs","opts","decimal","hex","octal","err","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","anum","bnum","vglobal","inverted","matchedLines","nextCommand","substitute","trailing","replacePart","confirm","startPos","doReplace","write","nohlsearch","delmarks","sym","startMark","finishMark","searchCursor","exMode","modifiedLineNumber","joined","replaceAll","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","cloneVimState","forEach","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","forEachSelection","virtualSelection","initVim","CodeMirror5","Vim","WORD","RANGE","editor","curWord","seen","GUTTER_ID","LINT_LINE_ID","showTooltip","tt","lint","selfContain","opacity","hideTooltip","showTooltipFor","tooltip","hide","LintState","conf","hasGutter","marked","Function","getAnnotations","linterOptions","timeout","onMouseOver","waitingFor","highlightLines","tooltips","lintOnChange","async","formatAnnotation","onUpdateLinting","clearMarks","clearErrorLines","makeMarker","labels","severity","multiple","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","messageHTML","lintAsync","abort","arg2","updateLinting","startLinting","then","issues","annotationsNotSorted","anns","item","maxSeverity","tipLabel","__annotation","popupTooltips","hasLintGutter","ie_lt8","matching","config","afterCursor","maxScanLen","maxScanLineLength","maxScanLines","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","highlightNonMatching","doMatchBrackets","currentlyHighlighted","clearHighlighted","oldConfig","defineProperty","configurable","enumerable","__esModule","default","TypeError","writable","codemirror","cminstance","unseenLines","merge","Boolean","globalOptions","globalEvents","watch","deep","$nextTick","switchMerge","handerCodeChange","methods","initialize","MergeView","$refs","mergeview","edit","$emit","unseenLineMarkers","destroy","mounted","beforeDestroy","install","u","component","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","_ssrRegister","beforeCreate","_injectStyles","esModule","$createElement","_self","_c","staticClass","attrs","findPosSubword","cat","moveSubword","insertLine","newSelection","wordAt","addCursorToSelection","newRange","isSelectedRange","goSubwordLeft","goSubwordRight","scrollLineUp","visibleBottomLine","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","skipAndSelectNextOccurrence","prevAnchor","prevHead","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","puncType","sortLines","caseSensitive","toSort","au","bu","modifyWordOrSelection","indices","replacements","getTarget","findAndGoTo","findPrevious","selectScope","goToBracket","swapLineUp","linesToMove","newSels","swapLineDown","toggleCommentIndented","toggleComment","actual","duplicateLine","reverseSortLines","sortLinesInsensitive","reverseSortLinesInsensitive","nextBookmark","sublimeBookmarks","prevBookmark","toggleBookmark","sublimeBookmark","clearBookmarks","selectBookmarks","smartBackspace","toStartOfLine","deletePos","prevIndent","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","selectToSublimeMark","deleteToSublimeMark","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","primaryIndex","macSublime","pcSublime","sublime","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","Completion","debounce","tick","startLen","updateOnCursorActivity","activityFunc","showHint","getHints","newOpts","parseOptions","supportsSelection","completionActive","completion","requestAnimationFrame","cancelAnimationFrame","hintOptions","resolve","getText","baseMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","pick","Tab","Esc","custom","customKeys","ourMap","addBinding","getHintElement","hintsElement","Widget","random","picked","parentWindow","hints","selectedHint","completions","hintId","alignWithWord","below","isContainerPositioned","offsetParentPosition","bodyPosition","winW","innerWidth","winH","startScroll","moveOnOverlap","DOMRect","scrolls","paddingForScrollbar","overlapY","spaceAbove","closingOnBlur","overlapX","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onScroll","curScroll","point","completeOnSingleClick","selectedHintRange","getSelectedHintRange","scrollToActive","applicableHelpers","fetchHints","resolveAutoHints","resolved","app","run","fromList","anyword","closeOnPick","identStart","closeCharacters","disable","myTick","finishUpdate","completeSingle","node1","node2","firstNode","scrollMargin","term","autocomplete","jsyaml","error","loadAll","loc","noFold","regexpFlags","flags","multiline","ensureFlags","maybeMultiline","searchRegexpForward","searchRegexpForwardMultiline","inside","lastMatchIn","endMargin","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","adjustPos","folded","foldFunc","searchStringForward","caseFold","cutFrom","endString","searchStringBackward","topString","SearchCursor","atOccurrence","afterEmptyMatch","normalize","foldGutter","onGutterClick","onViewportChange","onFold","optionChange","State","updateInViewport","indicatorOpen","indicatorFolded","isFolded","updateFoldInfo","foldOption","clsFolded","clsOpen","vp","changeUpdate","foldOnChangeTimeSpan","updateViewportTimeSpan","cons","keywordRegex","esc","escaped","literal","keyCol","pair","pairStart","inlinePairs","inlineList","lineComment","isLineComment","commentIndent","spaceTo","lineIndent","strPad","Vue","use","VueCodemirror","myIndent","lastLineInFold","regex","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","atom","isOperatorChar","isJsonldKeyword","readRegexp","inSet","tp","cont","tokenBase","tokenize","tokenString","tokenComment","expressionAllowed","tokenQuasi","lexical","lastType","propertyIsEnumerable","quote","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","sawSomething","atomicTypes","JSLexical","inScope","varname","localVars","cx","vars","parseJS","cc","combinator","expression","statement","lex","pass","inList","newContext","registerVarScoped","Var","globalVars","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","property","continueQuasi","targetNoComma","maybeTypeArgs","getterSetter","afterprop","maybetype","what","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","basecolumn","firstChar","doubleIndentSwitch","blockCommentStart","blockCommentEnd","blockCommentContinue","closeBrackets","skipExpression"],"mappings":"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","file":"js/codemirror.ba344358.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(dialog, \"focusout\", function (evt) {\n        if (evt.relatedTarget !== null) close();\n      });\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  // Internal generic kill function, used by several mapped kill \"family\" functions.\n  function _kill(cm, from, to, ring, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (ring == \"grow\" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else if (ring !== false)\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (ring == \"grow\") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir, ring) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);\n    }\n  }\n\n  function _killRegion(cm, ring) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        _kill(cm, selection.anchor, selection.head, ring);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  cmds.setMark = function (cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function makePrompt(msg) {\n    var fragment = document.createDocumentFragment();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    input.style.width = \"10em\";\n    fragment.appendChild(document.createTextNode(msg + \": \"));\n    fragment.appendChild(input);\n    return fragment;\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(makePrompt(msg), f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Commands. Names should match emacs function names (albeit in camelCase)\n  // except where emacs function names collide with code mirror core commands.\n\n  cmds.killRegion = function(cm) {\n    _kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"), true);\n  };\n\n  // Maps to emacs kill-line\n  cmds.killLineEmacs = repeated(function(cm) {\n    var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n    var text = cm.getRange(start, end);\n    if (!/\\S/.test(text)) {\n      text += \"\\n\";\n      end = Pos(start.line + 1, 0);\n    }\n    _kill(cm, start, end, \"grow\", text);\n  });\n\n  cmds.killRingSave = function(cm) {\n    addToRing(cm.getSelection());\n    clearMark(cm);\n  };\n\n  cmds.yank = function(cm) {\n    var start = cm.getCursor();\n    cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n    cm.setSelection(start, cm.getCursor());\n  };\n\n  cmds.yankPop = function(cm) {\n    cm.replaceSelection(popFromRing(), \"around\", \"paste\");\n  };\n\n  cmds.forwardChar = move(byChar, 1);\n\n  cmds.backwardChar = move(byChar, -1)\n\n  cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };\n\n  cmds.deleteForwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, 1, false);\n  };\n\n  cmds.deleteBackwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, -1, false);\n  };\n\n  cmds.forwardWord = move(byWord, 1);\n\n  cmds.backwardWord = move(byWord, -1);\n\n  cmds.killWord = function(cm) { killTo(cm, byWord, 1, \"grow\"); };\n\n  cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, \"grow\"); };\n\n  cmds.nextLine = move(byLine, 1);\n\n  cmds.previousLine = move(byLine, -1);\n\n  cmds.scrollDownCommand = move(byPage, -1);\n\n  cmds.scrollUpCommand = move(byPage, 1);\n\n  cmds.backwardParagraph = move(byParagraph, -1);\n\n  cmds.forwardParagraph = move(byParagraph, 1);\n\n  cmds.backwardSentence = move(bySentence, -1);\n\n  cmds.forwardSentence = move(bySentence, 1);\n\n  cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, \"grow\"); };\n\n  cmds.backwardKillSentence = function(cm) {\n    _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), \"grow\");\n  };\n\n  cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, \"grow\"); };\n\n  cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, \"grow\"); };\n\n  cmds.forwardSexp = move(byExpr, 1);\n\n  cmds.backwardSexp = move(byExpr, -1);\n\n  cmds.markSexp = function(cm) {\n    var cursor = cm.getCursor();\n    cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n  };\n\n  cmds.transposeSexps = function(cm) {\n    var leftStart = byExpr(cm, cm.getCursor(), -1);\n    var leftEnd = byExpr(cm, leftStart, 1);\n    var rightEnd = byExpr(cm, leftEnd, 1);\n    var rightStart = byExpr(cm, rightEnd, -1);\n    cm.replaceRange(cm.getRange(rightStart, rightEnd) +\n                    cm.getRange(leftEnd, rightStart) +\n                    cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n  };\n\n  cmds.backwardUpList = repeated(toEnclosingExpr);\n\n  cmds.justOneSpace = function(cm) {\n    var pos = cm.getCursor(), from = pos.ch;\n    var to = pos.ch, text = cm.getLine(pos.line);\n    while (from && /\\s/.test(text.charAt(from - 1))) --from;\n    while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n    cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n  };\n\n  cmds.openLine = repeated(function(cm) {\n    cm.replaceSelection(\"\\n\", \"start\");\n  });\n\n  // maps to emacs 'transpose-chars'\n  cmds.transposeCharsRepeatable = repeated(function(cm) {\n    cm.execCommand(\"transposeChars\");\n  });\n\n  cmds.capitalizeWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) {\n      var letter = w.search(/\\w/);\n      if (letter == -1) return w;\n      return w.slice(0, letter) + w.charAt(letter).toUpperCase() +\n          w.slice(letter + 1).toLowerCase();\n    });\n  });\n\n  cmds.upcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toUpperCase(); });\n  });\n\n  cmds.downcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toLowerCase(); });\n  });\n\n  // maps to emacs 'undo'\n  cmds.undoRepeatable = repeated(\"undo\");\n\n  cmds.keyboardQuit = function(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  cmds.newline = repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); });\n\n  cmds.gotoLine = function(cm) {\n    var prefix = getPrefix(cm, true);\n    if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n    getInput(cm, \"Goto line\", function(str) {\n      var num;\n      if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n      cm.setCursor(num - 1);\n    });\n  };\n\n  cmds.indentRigidly = function(cm) {\n    cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n  };\n\n  cmds.exchangePointAndMark = function(cm) {\n    cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n  };\n\n  cmds.quotedInsertTab = repeated(\"insertTab\");\n\n  cmds.universalArgument = function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  };\n\n  CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};\n\n  // Actual keymap\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": \"killRegion\",\n    \"Ctrl-K\": \"killLineEmacs\",\n    \"Alt-W\": \"killRingSave\",\n    \"Ctrl-Y\": \"yank\",\n    \"Alt-Y\": \"yankPop\",\n    \"Ctrl-Space\": \"setMark\",\n    \"Ctrl-Shift-2\": \"setMark\",\n    \"Ctrl-F\": \"forwardChar\",\n    \"Ctrl-B\": \"backwardChar\",\n    \"Right\": \"forwardChar\",\n    \"Left\": \"backwardChar\",\n    \"Ctrl-D\": \"deleteChar\",\n    \"Delete\": \"deleteForwardChar\",\n    \"Ctrl-H\": \"deleteBackwardChar\",\n    \"Backspace\": \"deleteBackwardChar\",\n    \"Alt-F\": \"forwardWord\",\n    \"Alt-B\": \"backwardWord\",\n    \"Alt-Right\": \"forwardWord\",\n    \"Alt-Left\": \"backwardWord\",\n    \"Alt-D\": \"killWord\",\n    \"Alt-Backspace\": \"backwardKillWord\",\n    \"Ctrl-N\": \"nextLine\",\n    \"Ctrl-P\": \"previousLine\",\n    \"Down\": \"nextLine\",\n    \"Up\": \"previousLine\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStart\",\n    \"Alt-V\": \"scrollDownCommand\",\n    \"Ctrl-V\": \"scrollUpCommand\",\n    \"PageUp\": \"scrollDownCommand\",\n    \"PageDown\": \"scrollUpCommand\",\n    \"Ctrl-Up\": \"backwardParagraph\",\n    \"Ctrl-Down\": \"forwardParagraph\",\n    \"Alt-{\": \"backwardParagraph\",\n    \"Alt-}\": \"forwardParagraph\",\n    \"Alt-A\": \"backwardSentence\",\n    \"Alt-E\": \"forwardSentence\",\n    \"Alt-K\": \"killSentence\",\n    \"Ctrl-X Delete\": \"backwardKillSentence\",\n    \"Ctrl-Alt-K\": \"killSexp\",\n    \"Ctrl-Alt-Backspace\": \"backwardKillSexp\",\n    \"Ctrl-Alt-F\": \"forwardSexp\",\n    \"Ctrl-Alt-B\": \"backwardSexp\",\n    \"Shift-Ctrl-Alt-2\": \"markSexp\",\n    \"Ctrl-Alt-T\": \"transposeSexps\",\n    \"Ctrl-Alt-U\": \"backwardUpList\",\n    \"Alt-Space\": \"justOneSpace\",\n    \"Ctrl-O\": \"openLine\",\n    \"Ctrl-T\": \"transposeCharsRepeatable\",\n    \"Alt-C\": \"capitalizeWord\",\n    \"Alt-U\": \"upcaseWord\",\n    \"Alt-L\": \"downcaseWord\",\n    \"Alt-;\": \"toggleComment\",\n    \"Ctrl-/\": \"undoRepeatable\",\n    \"Shift-Ctrl--\": \"undoRepeatable\",\n    \"Ctrl-Z\": \"undoRepeatable\",\n    \"Cmd-Z\": \"undoRepeatable\",\n    \"Ctrl-X U\": \"undoRepeatable\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Shift-Alt-,\": \"goDocStart\",\n    \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\",\n    \"Ctrl-R\": \"findPersistentPrev\",\n    \"Ctrl-G\": \"keyboardQuit\",\n    \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": \"newline\",\n    \"Tab\": \"indentAuto\",\n    \"Alt-G G\": \"gotoLine\",\n    \"Ctrl-X Tab\": \"indentRigidly\",\n    \"Ctrl-X Ctrl-X\": \"exchangePointAndMark\",\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X H\": \"selectAll\",\n    \"Ctrl-Q Tab\": \"quotedInsertTab\",\n    \"Ctrl-U\": \"universalArgument\",\n    \"fallthrough\": \"default\"\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      if (force === \"fold\") return range;\n\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options, range);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options, range) {\n    var widget = getOption(cm, options, \"widget\");\n\n    if (typeof widget == \"function\") {\n      widget = widget(range.from, range.to);\n    }\n\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), { scanUp: false }, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// This is CodeMirror (https://codemirror.net/5), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);\n  var chrome_version = chrome && +chrome[1];\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt(doc) {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = doc.activeElement;\n    } catch(e) {\n      activeElement = doc.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function doc(cm) { return cm.display.wrapper.ownerDocument }\n\n  function win(cm) { return doc(cm).defaultView }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints(\"StartToEnd\", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n\n  // Add a span to a line.\n  function addMarkedSpan(line, span, op) {\n    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));\n    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {\n      line.markedSpans.push(span);\n    } else {\n      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n      if (inThisOp) { inThisOp.add(line.markedSpans); }\n    }\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    if (lineView.rest) {\n      for (var i = 0; i < lineView.rest.length; i++)\n        { if (lineView.rest[i] == line)\n          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n        { if (lineNo(lineView.rest[i$1]) > lineN)\n          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n    }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX(doc) {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(doc.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc.body).marginLeft)) }\n    return doc.defaultView.pageXOffset || (doc.documentElement || doc.body).scrollLeft\n  }\n  function pageScrollY(doc) {\n    if (chrome && android) { return -(doc.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc.body).marginTop)) }\n    return doc.defaultView.pageYOffset || (doc.documentElement || doc.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var ref = visualLine(lineObj);\n    var widgets = ref.widgets;\n    var height = 0;\n    if (widgets) { for (var i = 0; i < widgets.length; ++i) { if (widgets[i].above)\n      { height += widgetHeight(widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY(doc(cm)));\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX(doc(cm)));\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX(doc(cm));\n      top -= pageScrollY(doc(cm));\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    var customCursor = cm.options.$customCursor;\n    if (customCursor) { primary = true; }\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (customCursor) {\n        var head = customCursor(cm, range);\n        if (head) { drawSelectionCursor(cm, head, curFragment); }\n      } else if (collapsed || cm.options.showCursorWhenSelecting) {\n        drawSelectionCursor(cm, range.head, curFragment);\n      }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n      var charPos = charCoords(cm, head, \"div\", null, null);\n      var width = charPos.right - charPos.left;\n      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + \"px\";\n    }\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n    var oldHeight = display.lineDiv.getBoundingClientRect().top;\n    var mustScroll = 0;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      oldHeight += cur.line.height;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        if (oldHeight < viewTop) { mustScroll -= diff; }\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    var doc = display.wrapper.ownerDocument;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (doc.defaultView.innerHeight || doc.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.scrollTop = 0;\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.visibility = this.vert.style.visibility = \"hidden\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.visibility = \"\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.visibility = \"hidden\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId,          // Unique ID\n      markArrays: null         // Used by addMarkedSpan\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt(doc(cm));\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt(doc(cm));\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = win(cm).getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(snapshot.activeElt.ownerDocument)) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var doc = snapshot.activeElt.ownerDocument;\n      var sel = doc.defaultView.getSelection(), range = doc.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n    // Send an event to consumers responding to changes in gutter width.\n    signalLater(display, \"gutterChanged\", display);\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n    // See #6982. FIXME remove when this has been fixed for a while in Chrome\n    if (chrome && chrome_version >= 105) { d.wrapper.style.clipPath = \"inset(0px)\"; }\n\n    // This attribute is respected by automatic translation systems such as Google Translate,\n    // and may also be respected by tools used by human translators.\n    d.wrapper.setAttribute('translate', 'no');\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    // On Chrome 102, viewport updates somehow stop wheel-based\n    // scrolling. Turning off pointer events during the scroll seems\n    // to avoid the issue.\n    if (chrome && chrome_version == 102) {\n      if (cm.display.chromeScrollHack == null) { cm.display.sizer.style.pointerEvents = \"none\"; }\n      else { clearTimeout(cm.display.chromeScrollHack); }\n      cm.display.chromeScrollHack = setTimeout(function () {\n        cm.display.chromeScrollHack = null;\n        cm.display.sizer.style.pointerEvents = \"\";\n      }, 100);\n    }\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n    var pixelsPerUnit = wheelPixelsPerUnit;\n    if (e.deltaMode === 0) {\n      dx = e.deltaX;\n      dy = e.deltaY;\n      pixelsPerUnit = 1;\n    }\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && pixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && pixelsPerUnit != null) {\n      var pixels = dy * pixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20 && e.deltaMode !== 0) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    cm.options.direction = doc.direction;\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(prev) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = prev ? prev.undoDepth : Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\")\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = range.head == range.anchor ? newAnchor : skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      if (lineSep === '') { return lines.join('') }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range.head; }\n      else if (start == \"anchor\") { pos = range.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head || ranges[i].anchor)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 224: \"Mod\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\", \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\", \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"codepoint\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt(doc(cm));\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand(\"cut\"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    win(cm).focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(doc(cm)); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc$1 = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc$1.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc$1.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc$1.sel.primary();\n      ourIndex = doc$1.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc$1, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc$1.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc$1, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc$1, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc$1.sel;\n    } else {\n      replaceOneSelection(doc$1, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc$1, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc$1, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc$1, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc$1, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc$1, anchor), head));\n        setSelection(doc$1, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt(doc(cm));\n        extendTo(cur);\n        var visible = visibleLines(display, doc$1);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc$1.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = (val === '') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus())\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){win(this).focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, \"div\");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt(doc(this)) },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == \"number\") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \"widget\"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc(cm).documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    div.contentEditable = true;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = activeElt(div.ownerDocument);\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = activeElt(this.div.ownerDocument) == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || activeElt(this.div.ownerDocument) != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n      var this$1 = this;\n\n    var input = this;\n    if (this.selectionInEditor())\n      { setTimeout(function () { return this$1.pollSelection(); }, 20); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n    this.resetting = false;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing && typing) { return }\n    var cm = this.cm;\n    this.resetting = true;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n    this.resetting = false;\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt(this.textarea.ownerDocument) != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || this.resetting || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = te.ownerDocument.defaultView.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { te.ownerDocument.defaultView.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt(textarea.ownerDocument);\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, */) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.65.9\";\n\n  return CodeMirror;\n\n})));\n","(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n    'use strict';\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim$1(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction initVim(CodeMirror5) {\r\n  CodeMirror5.Vim = initVim$1(CodeMirror5);\r\n  return CodeMirror5.Vim;\r\n}\n\n\n\n    CodeMirror.Vim = initVim(CodeMirror);\n  });\n  ","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n\n  function showTooltip(cm, e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n    tt.appendChild(content.cloneNode(true));\n    if (cm.state.lint.options.selfContain)\n      cm.getWrapperElement().appendChild(tt);\n    else\n      document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(cm, e, content, node) {\n    var tooltip = showTooltip(cm, e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, conf, hasGutter) {\n    this.marked = [];\n    if (conf instanceof Function) conf = {getAnnotations: conf};\n    if (!conf || conf === true) conf = {};\n    this.options = {};\n    this.linterOptions = conf.options || {};\n    for (var prop in defaults) this.options[prop] = defaults[prop];\n    for (var prop in conf) {\n      if (defaults.hasOwnProperty(prop)) {\n        if (conf[prop] != null) this.options[prop] = conf[prop];\n      } else if (!conf.options) {\n        this.linterOptions[prop] = conf[prop];\n      }\n    }\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  var defaults = {\n    highlightLines: false,\n    tooltips: true,\n    delay: 500,\n    lintOnChange: true,\n    getAnnotations: null,\n    async: false,\n    selfContain: null,\n    formatAnnotation: null,\n    onUpdateLinting: null\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    if (state.options.highlightLines) clearErrorLines(cm);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function clearErrorLines(cm) {\n    cm.eachLine(function(line) {\n      var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n      if (has) cm.removeLineClass(line, \"wrap\", has[0]);\n    })\n  }\n\n  function makeMarker(cm, labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(cm, e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n      tip.innerHTML = ann.messageHTML;\n    } else {\n      tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      cm.operation(function() {updateLinting(cm, annotations)})\n    }, state.linterOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        cm.operation(function() {updateLinting(cm, issues)})\n      });\n      else cm.operation(function() {updateLinting(cm, annotations)})\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    clearMarks(cm);\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      // filter out duplicate messages\n      var message = [];\n      anns = anns.filter(function(item) { return message.indexOf(item.message) > -1 ? false : message.push(item.message) });\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n      // use original annotations[line] to show multiple messages\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations[line].length > 1,\n                                                       options.tooltips));\n\n      if (options.highlightLines)\n        cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);\n  }\n\n  function popupTooltips(cm, annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(cm, e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(cm, annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n      if (state.options.lintOnChange)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    startLinting(this);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined ||\n                            (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n      highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets)\n      cm.off(\"blur\", clearHighlighted)\n      clearHighlighted(cm);\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets)\n      cm.on(\"blur\", clearHighlighted)\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"codemirror\")):\"function\"==typeof define&&define.amd?define([\"codemirror\"],t):\"object\"==typeof exports?exports.VueCodemirror=t(require(\"codemirror\")):e.VueCodemirror=t(e.codemirror)}(this,function(e){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"/\",t(t.s=3)}([function(t,n){t.exports=e},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(0),o=function(e){return e&&e.__esModule?e:{default:e}}(r),i=window.CodeMirror||o.default;\"function\"!=typeof Object.assign&&Object.defineProperty(Object,\"assign\",{value:function(e,t){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var n=Object(e),r=1;r<arguments.length;r++){var o=arguments[r];if(null!=o)for(var i in o)Object.prototype.hasOwnProperty.call(o,i)&&(n[i]=o[i])}return n},writable:!0,configurable:!0}),t.default={name:\"codemirror\",data:function(){return{content:\"\",codemirror:null,cminstance:null}},props:{code:String,value:String,marker:Function,unseenLines:Array,name:{type:String,default:\"codemirror\"},placeholder:{type:String,default:\"\"},merge:{type:Boolean,default:!1},options:{type:Object,default:function(){return{}}},events:{type:Array,default:function(){return[]}},globalOptions:{type:Object,default:function(){return{}}},globalEvents:{type:Array,default:function(){return[]}}},watch:{options:{deep:!0,handler:function(e){for(var t in e)this.cminstance.setOption(t,e[t])}},merge:function(){this.$nextTick(this.switchMerge)},code:function(e){this.handerCodeChange(e)},value:function(e){this.handerCodeChange(e)}},methods:{initialize:function(){var e=this,t=Object.assign({},this.globalOptions,this.options);this.merge?(this.codemirror=i.MergeView(this.$refs.mergeview,t),this.cminstance=this.codemirror.edit):(this.codemirror=i.fromTextArea(this.$refs.textarea,t),this.cminstance=this.codemirror,this.cminstance.setValue(this.code||this.value||this.content)),this.cminstance.on(\"change\",function(t){e.content=t.getValue(),e.$emit&&e.$emit(\"input\",e.content)});var n={};[\"scroll\",\"changes\",\"beforeChange\",\"cursorActivity\",\"keyHandled\",\"inputRead\",\"electricInput\",\"beforeSelectionChange\",\"viewportChange\",\"swapDoc\",\"gutterClick\",\"gutterContextMenu\",\"focus\",\"blur\",\"refresh\",\"optionChange\",\"scrollCursorIntoView\",\"update\"].concat(this.events).concat(this.globalEvents).filter(function(e){return!n[e]&&(n[e]=!0)}).forEach(function(t){e.cminstance.on(t,function(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];e.$emit.apply(e,[t].concat(r));var i=t.replace(/([A-Z])/g,\"-$1\").toLowerCase();i!==t&&e.$emit.apply(e,[i].concat(r))})});this.$emit(\"ready\",this.codemirror),this.unseenLineMarkers(),this.refresh()},refresh:function(){var e=this;this.$nextTick(function(){e.cminstance.refresh()})},destroy:function(){var e=this.cminstance.doc.cm.getWrapperElement();e&&e.remove&&e.remove()},handerCodeChange:function(e){if(e!==this.cminstance.getValue()){var t=this.cminstance.getScrollInfo();this.cminstance.setValue(e),this.content=e,this.cminstance.scrollTo(t.left,t.top)}this.unseenLineMarkers()},unseenLineMarkers:function(){var e=this;void 0!==this.unseenLines&&void 0!==this.marker&&this.unseenLines.forEach(function(t){var n=e.cminstance.lineInfo(t);e.cminstance.setGutterMarker(t,\"breakpoints\",n.gutterMarkers?null:e.marker())})},switchMerge:function(){var e=this.cminstance.doc.history,t=this.cminstance.doc.cleanGeneration;this.options.value=this.cminstance.getValue(),this.destroy(),this.initialize(),this.cminstance.doc.history=e,this.cminstance.doc.cleanGeneration=t}},mounted:function(){this.initialize()},beforeDestroy:function(){this.destroy()}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(1),o=n.n(r);for(var i in r)[\"default\",\"default\"].indexOf(i)<0&&function(e){n.d(t,e,function(){return r[e]})}(i);var s=n(5),c=n(4),a=c(o.a,s.a,!1,null,null,null);t.default=a.exports},function(e,t,n){\"use strict\";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"__esModule\",{value:!0}),t.install=t.codemirror=t.CodeMirror=void 0;var o=n(0),i=r(o),s=n(2),c=r(s),a=window.CodeMirror||i.default,u=function(e,t){t&&(t.options&&(c.default.props.globalOptions.default=function(){return t.options}),t.events&&(c.default.props.globalEvents.default=function(){return t.events})),e.component(c.default.name,c.default)},l={CodeMirror:a,codemirror:c.default,install:u};t.default=l,t.CodeMirror=a,t.codemirror=c.default,t.install=u},function(e,t){e.exports=function(e,t,n,r,o,i){var s,c=e=e||{},a=typeof e.default;\"object\"!==a&&\"function\"!==a||(s=e,c=e.default);var u=\"function\"==typeof c?c.options:c;t&&(u.render=t.render,u.staticRenderFns=t.staticRenderFns,u._compiled=!0),n&&(u.functional=!0),o&&(u._scopeId=o);var l;if(i?(l=function(e){e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,e||\"undefined\"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(i)},u._ssrRegister=l):r&&(l=r),l){var f=u.functional,d=f?u.render:u.beforeCreate;f?(u._injectStyles=l,u.render=function(e,t){return l.call(t),d(e,t)}):u.beforeCreate=d?[].concat(d,l):[l]}return{esModule:s,exports:c,options:u}}},function(e,t,n){\"use strict\";var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{staticClass:\"vue-codemirror\",class:{merge:e.merge}},[e.merge?n(\"div\",{ref:\"mergeview\"}):n(\"textarea\",{ref:\"textarea\",attrs:{name:e.name,placeholder:e.placeholder}})])},o=[],i={render:r,staticRenderFns:o};t.a=i}])});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type, startPos = start.ch;\n    for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n        else startPos = pos + dir\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { // From uppercase to lowercase\n            if (pos == startPos + 1) { type = \"w\"; continue; }\n            else pos--;\n          }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };\n  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };\n\n  cmds.scrollLineUp = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds.scrollLineDown = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds.selectLine = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };\n\n  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds.selectNextOccurrence = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  cmds.skipAndSelectNextOccurrence = function(cm) {\n    var prevAnchor = cm.getCursor(\"anchor\"), prevHead = cm.getCursor(\"head\");\n    cmds.selectNextOccurrence(cm);\n    if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n      cm.doc.setSelections(cm.doc.listSelections()\n          .filter(function (sel) {\n            return sel.anchor != prevAnchor || sel.head != prevHead;\n          }));\n    }\n  }\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(\n          range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(\n          range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ?\n          range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ?\n          range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };\n  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 &&\n          CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&\n              CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({anchor: startPos, head: closing.pos});\n            break;\n          }\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds.selectBetweenBrackets = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  function puncType(type) {\n    return !type ? null : /\\bpunctuation\\b/.test(type) ? type : undefined\n  }\n\n  cmds.goToBracket = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds.joinLines = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n\n  function sortLines(cm, caseSensitive, direction) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort(function(a, b) { return a < b ? -direction : a == b ? 0 : direction; });\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -direction : a == b ? 0 : direction;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function(cm) { sortLines(cm, true, 1); };\n  cmds.reverseSortLines = function(cm) { sortLines(cm, true, -1); };\n  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false, 1); };\n  cmds.reverseSortLinesInsensitive = function(cm) { sortLines(cm, false, -1); };\n\n  cmds.nextBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds.clearBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds.downcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds.setSublimeMark = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds.selectToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds.deleteToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds.swapWithSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds.sublimeYank = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };\n  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };\n  cmds.findAllUnder = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Shift-F5\": \"reverseSortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-1\": \"foldAll\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Shift-F9\": \"reverseSortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-1\": \"foldAll\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: DOMRect\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    if (this.options.updateOnCursorActivity) {\n      var self = this;\n      cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n    }\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      if (this.options.updateOnCursorActivity) {\n        this.cm.off(\"cursorActivity\", this.activityFunc);\n      }\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i], self = this;\n      this.cm.operation(function() {\n        if (completion.hint)\n          completion.hint(self.cm, data, completion);\n        else\n          self.cm.replaceRange(getText(completion), completion.from || data.from,\n                               completion.to || data.to, \"complete\");\n        CodeMirror.signal(data, \"pick\", completion);\n        self.cm.scrollIntoView();\n      });\n      if (this.options.closeOnPick) {\n        this.close();\n      }\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var identStart = this.startPos;\n      if(this.data) {\n        identStart = this.data.from;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < identStart.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.id = \"cm-complete-\" + Math.floor(Math.random(1e6))\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    hints.setAttribute(\"role\", \"listbox\")\n    hints.setAttribute(\"aria-expanded\", \"true\")\n    hints.id = this.id\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (i == this.selectedHint) elt.setAttribute(\"aria-selected\", \"true\")\n      elt.id = this.id + \"-\" + i\n      elt.setAttribute(\"role\", \"option\")\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var container = completion.options.container || ownerDocument.body;\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    var offsetLeft = 0, offsetTop = 0;\n    if (container !== ownerDocument.body) {\n      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.\n      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n      var offsetParent = isContainerPositioned ? container : container.offsetParent;\n      var offsetParentPosition = offsetParent.getBoundingClientRect();\n      var bodyPosition = ownerDocument.body.getBoundingClientRect();\n      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);\n      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);\n    }\n    hints.style.left = (left - offsetLeft) + \"px\";\n    hints.style.top = (top - offsetTop) + \"px\";\n\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    container.appendChild(hints);\n    cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\")\n    cm.getInputField().setAttribute(\"aria-owns\", this.id)\n    cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint)\n\n    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n\n    // Compute in the timeout to avoid reflow on init\n    var startScroll;\n    setTimeout(function() { startScroll = cm.getScrollInfo(); });\n\n    var overlapY = box.bottom - winH;\n    if (overlapY > 0) { // Does not fit below\n      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2\n      if (winH - box.top < spaceAbove) { // More room at the top\n        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + \"px\";\n        hints.style.top = ((top = pos.top - height) + offsetTop) + \"px\";\n        below = false;\n      } else {\n        hints.style.height = (winH - box.top - 2) + \"px\";\n      }\n    }\n    var overlapX = box.right - winW;\n    if (scrolls) overlapX += cm.display.nativeBarWidth;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      if (!startScroll) startScroll = cm.getScrollInfo();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    // The first hint doesn't need to be scrolled to on init\n    var selectedHintRange = this.getSelectedHintRange();\n    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n      this.scrollToActive();\n    }\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var input = this.completion.cm.getInputField()\n      input.removeAttribute(\"aria-activedescendant\")\n      input.removeAttribute(\"aria-owns\")\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) {\n        node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n        node.removeAttribute(\"aria-selected\")\n      }\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      node.setAttribute(\"aria-selected\", \"true\")\n      this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id)\n      this.scrollToActive()\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    scrollToActive: function() {\n      var selectedHintRange = this.getSelectedHintRange();\n      var node1 = this.hints.childNodes[selectedHintRange.from];\n      var node2 = this.hints.childNodes[selectedHintRange.to];\n      var firstNode = this.hints.firstChild;\n      if (node1.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    },\n\n    getSelectedHintRange: function() {\n      var margin = this.completion.options.scrollMargin || 0;\n      return {\n        from: Math.max(0, this.selectedHint - margin),\n        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),\n      };\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnPick: true,\n    closeOnUnfocus: true,\n    updateOnCursorActivity: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null,\n    paddingForScrollbar: true,\n    moveOnOverlap: true,\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n// Depends on js-yaml.js from https://github.com/nodeca/js-yaml\n\n// declare global: jsyaml\n\nCodeMirror.registerHelper(\"lint\", \"yaml\", function(text) {\n  var found = [];\n  if (!window.jsyaml) {\n    if (window.console) {\n      window.console.error(\"Error: window.jsyaml not defined, CodeMirror YAML linting cannot run.\");\n    }\n    return found;\n  }\n  try { jsyaml.loadAll(text); }\n  catch(e) {\n      var loc = e.mark,\n          // js-yaml YAMLException doesn't always provide an accurate lineno\n          // e.g., when there are multiple yaml docs\n          // ---\n          // ---\n          // foo:bar\n          from = loc ? CodeMirror.Pos(loc.line, loc.column) : CodeMirror.Pos(0, 0),\n          to = from;\n      found.push({ from: from, to: to, message: e.message });\n  }\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.afterEmptyMatch = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch)\n        if (reverse) {\n          head.ch--;\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n           return this.atOccurrence = false\n        }\n      }\n      var result = this.matches(reverse, head)\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"changes\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n      cm.off(\"optionChange\", optionChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"changes\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n      cm.on(\"optionChange\", optionChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i) {\n      if (marks[i].__isFold) {\n        var fromPos = marks[i].find(-1);\n        if (fromPos && fromPos.line === line)\n          return marks[i];\n      }\n    }\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from - 1;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    // we can reuse the built-in indicator element if its className matches the new state\n    var clsFolded = typeof opts.indicatorFolded == \"string\" && classTest(opts.indicatorFolded);\n    var clsOpen = typeof opts.indicatorOpen == \"string\" && classTest(opts.indicatorOpen);\n    cm.eachLine(from, to, function(line) {\n      ++cur;\n      var mark = null;\n      var old = line.gutterMarkers;\n      if (old) old = old[opts.gutter];\n      if (isFolded(cm, cur)) {\n        if (clsFolded && old && clsFolded.test(old.className)) return;\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize) {\n          if (clsOpen && old && clsOpen.test(old.className)) return;\n          mark = marker(opts.indicatorOpen);\n        }\n      }\n      if (!mark && !old) return;\n      cm.setGutterMarker(line, opts.gutter, mark);\n    });\n  }\n\n  // copied from CodeMirror/src/util/dom.js\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts);\n  }\n\n  function optionChange(cm, option) {\n    if (option == \"mode\") onChange(cm)\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match('---')) { return \"def\"; }\n        /* document end */\n        if (stream.match('...')) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list separator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs separator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n","/*\n * NOTE: This isn't actually a real plugin anymore, it's is dynamically loaded in components/CodeMirror.vue\n * so that it doesn't all get loaded put into vendor.js\n */\n\nimport Vue from 'vue';\nimport VueCodemirror from 'vue-codemirror';\nimport CodeMirror from 'codemirror';\n\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/mode/yaml/yaml.js';\nimport 'codemirror/mode/javascript/javascript.js';\n\n// import 'codemirror/mode/dockerfile/dockerfile.js';\n// import 'codemirror/mode/shell/shell.js';\n// import 'codemirror/mode/markdown/markdown.js';\n\nimport 'codemirror/theme/base16-light.css';\nimport 'codemirror/theme/base16-dark.css';\n\nimport 'codemirror/keymap/vim.js';\nimport 'codemirror/keymap/emacs.js';\nimport 'codemirror/keymap/sublime.js';\n\nimport 'codemirror/addon/lint/lint.css';\nimport 'codemirror/addon/lint/lint.js';\nimport 'codemirror/addon/lint/yaml-lint.js';\n\nimport 'codemirror/addon/fold/foldgutter.css';\nimport 'codemirror/addon/fold/foldgutter.js';\n\nimport 'codemirror/addon/hint/show-hint.css';\nimport 'codemirror/addon/hint/show-hint.js';\nimport 'codemirror/addon/hint/anyword-hint.js';\n\nimport { strPad } from '@shell/utils/string';\n\nVue.use(VueCodemirror);\nexport default VueCodemirror;\n\nfunction isLineComment(cm, lineNo) {\n  return /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)));\n}\n\nfunction commentIndent(cm, lineNo) {\n  const text = cm.getLine(lineNo).substr(1);\n  const spaceTo = text.search(/\\S/);\n\n  if (spaceTo === -1 ) {\n    return -1;\n  }\n\n  const out = CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n\n  return out;\n}\n\n// Like the regular indent in codemirror, but treat a YAML array\n// item that's at the same level as the parent key as intented on level more\n//\n// foo:\n// - a\n// - b\nfunction lineIndent(cm, lineNo) {\n  let text = cm.getLine(lineNo);\n  const match = text.match(/(\\s*(-\\s+)?)(\\S.*)/);\n\n  if ( !match ) {\n    return -1;\n  }\n\n  const spaceTo = match[1].length;\n\n  text = strPad('', spaceTo) + match[3];\n\n  if ( /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1)))) {\n    return -1;\n  }\n\n  return CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n}\n\n// https://github.com/codemirror/CodeMirror/blob/master/addon/fold/indent-fold.js\nCodeMirror.registerHelper('fold', 'indent', (cm, start) => {\n  const myIndent = lineIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    const indent = lineIndent(cm, i);\n\n    if (indent === -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\nCodeMirror.defineExtension('foldLinesMatching', function(regex) {\n  this.operation(() => {\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n\n      if ( line.match(regex) ) {\n        this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n      }\n    }\n  });\n});\n\nCodeMirror.registerHelper('fold', 'yamlcomments', (cm, start) => {\n  if ( !isLineComment(cm, start.line) ) {\n    return;\n  }\n\n  const myIndent = commentIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    if ( !isLineComment(cm, i) ) {\n      break;\n    }\n\n    const indent = commentIndent(cm, i);\n\n    if (indent === -1) {\n      // empty?\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  pushcontext.lex = pushblockcontext.lex = true\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n"],"sourceRoot":""}